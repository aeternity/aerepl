#!/usr/bin/env escript
%% -*- erlang -*-
%%! -smp enable -setcookie aerepl_cookie -mnesia debug verbose
-mode(compile).

load_paths() ->
    ScriptDir = filename:dirname(escript:script_name()),
    Paths = filelib:wildcard("_build/prod/lib/*/ebin/", ScriptDir),
    [code:add_pathz(filename:append(ScriptDir, Path))
     orelse error({not_found, filename:append(ScriptDir, Path)})
     || Path <- Paths],
    ok.

main(_Args) ->
    load_paths(),
    {ok, _Sup} = aere_supervisor:start_link([]),
    start().

start() ->
    Banner = aere_gen_server:banner(),
    BannerStr = aere_gen_server:render(Banner),
    io:format("~s\n\n", [BannerStr]),
    loop().

loop() ->
    Input = get_input(),
    try aere_gen_server:input(Input) of
        {ok, finish} ->
            finish;
        {ok, Res} ->
            print_msg(Res),
            loop();
        {error, Err} ->
            print_msg({error, Err}),
            loop()
    catch
        _:E:Stack ->
            print_msg(aere_theme:render(aere_msg:internal_error(E, Stack))),
            loop()
    end.

print_msg(ok) -> ok;
print_msg(<<"">>) -> ok;
print_msg(Msg) when is_binary(Msg) ->
    io:format("~s\n", [Msg]);
print_msg(Item) ->
    Msg = aere_gen_server:format(Item),
    Str = aere_gen_server:render(Msg),
    print_msg(Str).


%% Get single line or multiline input from the user and return it as a single string
-spec get_input() -> string().
get_input() ->
    Prompt = aere_gen_server:prompt(),
    Line =
        case io:get_line(binary:bin_to_list(Prompt) ++ "> ") of
            eof          -> ":quit"; % that's dirty
            {error, Err} -> exit(Err);
            Data         -> Data
        end,
    Input =
        case string:trim(Line, both, unicode_util:whitespace()) of
            ":{" -> multiline_input();
            ""   -> "";
            _    -> lists:flatten(string:replace(Line, ";", "\n", all))
        end,
    string:trim(Input, both, unicode_util:whitespace()).

-spec multiline_input() -> string().
multiline_input() -> multiline_input([]).

%% Keep reading input lines until :} is found. Return the code between :{ and :} as a single string
-spec multiline_input([string()]) -> string().
multiline_input(CodeBlock) ->
    Line = io:get_line("| "),
    case string:trim(Line, both, unicode_util:whitespace()) of
        ":}" -> lists:flatten(lists:reverse(CodeBlock));
        _    -> multiline_input([Line|CodeBlock])
    end.
